;; -*- mode: Lisp; -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Explorations of hardware representations of value types and tagged
;; pointer types. Derived initially from C0 compiler, but modified heavily
;; for the C1 compiler.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; ;;;;
;; Narrow Tags (64-bit architecture)
;; ;;;;

;; Fixnum:          | 63-bit fixnum  | XXX0
;; Cons Cell        | 60-bit address | 0001
;; Closure:         | 60-bit address | 0011
;; UNUSED:          | 60-bit address | 0101 TODO: Broken Heart
;; Symbol:          | 60-bit address | 0111
;; Array:           | 60-bit address | 1001 (full of same type immediate)
;; TaggedArray:     | 60-bit address | 1011 (full of tagged pointers only)
;;
;; OtherImm tag:    | <whatever>     | 1101
;; Wide tag:        | <whatever>     | 1111

;; ;;;;
;; Other immediates
;; ;;;;

;; UTF-8 char:    | 24 x 0 | 32-bits UTF-8 | 0000 | OtherImm Tag (left justi.)
;; False:         | 56 x 0                 | 0010 | OtherImm Tag
;; True:          | 56 x 0                 | 0011 | OtherImm Tag
;; Empty List:    | 56 x 0                 | 0100 | OtherImm Tag
;; eof:           | 56 x 0                 | 0101 | OtherImm Tag
;; void:          | 56 x 0                 | 0110 | OtherImm Tag
;; unbound:       | 56 x 0                 | 0111 | OtherImm Tag

;; ;;;;
;; Wide Tags
;; ;;;;

;; Executable Code: | 56 x 0 | 0000 | Wide Tag
;; Stack:           | 56 x 0 | 0001 | Wide Tag
;; Symbol Table:    | 56 x 0 | 0010 | Wide Tag
;; Hash Table:      | 56 x 0 | 0011 | Wide Tag
;; Bignum:          | 56 x 0 | 0100 | Wide Tag
;; Rational:        | 56 x 0 | 0101 | Wide Tag
;; Complex:         | 56 x 0 | 0110 | Wide Tag
;;
;; TODO: Add more, such as, single-floats and double-floats (eeewww figure that
;; out), boxed types whose storage is ALWAYS headerless, etc, etc, etc



;; ;;;;
;; Explicit examples of value type
;; ;;;;

;; Fixnum: Tag #b0
;; ===============
;; This is not a pointer, but an immediate representation of an integer.
;;
;; We choose this specific tag to make math operations like addition work out
;; on the tagged representation itself.
;;
;; Range: (1- (expt 2 -63)) to (expt 2 63)
;; (defparameter +word-size* 8) ;; bytes
;; (defparameter +fx-shift+ 1);; bits
;; (defun fixnum-bits () (- (* +word-size+ 8) +fx-shift+))
;; (defun fxlower () (- (expt 2 (- (fixnum-bits) 1))))
;; (defun fxupper () (1- (expt 2 (- (fixnum-bits) 1))))
;;
;; To convert a hardware integer to a fixnum, shift left 1 bit.
;; To convert a fixnum to a hardware integer, shift right 1 bit.
;; If it overflows during the shift, convert to bignum.
;; If a bignum is shifted right and fits into a fixnum, convert to fixnum.
;;
;; Example odd number, integer -> fixnum:
;;  Convert: 0x3039
;;  Arithmetic Shift left 1 bit: 0x6072
;;  Right most bit is already 0.
;; Example odd number, fixnum -> integer:
;;  Convert: 0x6072
;;  Arithmetic Shift Right 1 bit: 0x3039
;;  Left most bit is sign extended.
;;
;; Example even number, integer -> fixnum:
;;  Convert: 0x7678
;;  Arithmetic Shift Left 1 bit: 0xecf0
;;  Right most bit is already 0.
;; Example even number, fixnum -> integer:
;;  Convert: 0xecf0
;;  Arithmetic Shift Right 1 bit: 0x7678
;;  Left more bit is sign extended.
;;
;; If the left shift of an integer causes an overflow of a fixnum, the number
;; must be promoted to a bignum.


;; cons Cell: Tag #b0001
;; =====================
;;
;; It consists of two adjacent 8 byte quantities whose car is
;; aligned on 16 byte boundary
;; Example cons cell in memory:
;;  address of a car: 0x0011223344556670
;;  address of a cdr: 0x0011223344556678
;; Tagged ptr to above cell: 0x0011223344556671
;;
;; So, if %eax holds 0x0011223344556671, then
;; movq -1(%eax), %ebx ; moves the car into the %ebx register,
;; movq  7(%eax), %edx ; moves the cdr into the %edx register
